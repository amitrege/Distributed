module ST
    use import ref.Ref
    use import int.Int
    use import int.EuclideanDivision

    use import array.Array
    use import array.NumOf
    
    use import matrix.Matrix

    type message = Msg int (array int) int | Empty
    type message2 = Msg2 (array int) | Nil

    val temp : ref int 

    (*
        Initialize all elements of array to -1
    *)
    let init_vp (a : array int) (n : int) 
        requires {length a = n /\ n > 1}
        ensures {forall k:int. 0 <= k < n -> a[k] = -1}
    =
        for x = 0 to (n-1)
        do
        invariant {forall j:int. 0 <= j < x -> a[j] = -1}
            a[x]<- -1
        done

    predicate cmp1 (m1 : message) (m2 : message) 
    =
        match m1,m2 with
        | Empty, Empty -> True
        | _, _ -> False
        end 

    let cmp (m1 : message) (m2 : message) 
    =
        match m1,m2 with
        | Empty, Empty -> True
        | _, _ -> False
        end 

    let propose (v_p : array int) (delta_p : array int) (rcvd : matrix message) (msgs : array message) (pid: int) (rcvd2: array message) (n : int)
        requires {length v_p = n /\ length delta_p = n /\ n > 1}
        requires {rows rcvd = n /\ columns rcvd = n}
        requires {0 <= pid < n}
    =
        init_vp v_p n;
        init_vp delta_p n;

        (* All elements of v_p and delta_p initialized to -1 *)
        assert{forall j:int. 0 <= j < n -> v_p[j] = -1};
        assert{forall j:int. 0 <= j < n -> delta_p[j] = -1};

        v_p[pid] <- pid;
        delta_p[pid] <- pid; 

        (* Phase 1 *)
        for r_p = 1 to (n-1)
        do
            (* Send r_p, delta_p to all *)
            for x = 0 to n-1
            do 
                assert { 
                    match (Msg r_p delta_p pid), r_p, delta_p, pid with
                    | (Msg r_p v_p pid), r_p1, delta_p, pid1 -> if r_p1=r_p && pid1= pid then True else False
                    | _ -> False
                    end 
                };
            done;

            (* Receive and Initializing msgs *)
            for x = 0 to n-1
            do
                if not (cmp (get rcvd r_p x) Empty)
                then
                    msgs[x] <- (get rcvd r_p x)
                else
                   msgs[x] <- Empty 
            done;

            (* Reset delta_p *)
            init_vp delta_p n;

            let res = ref False in
            let temp = ref 0 in
            for k = 0 to n-1 
            do
                for x = 0 to n-1 
                do
                    if not (msgs[x] = Empty)
                    then
                        match msgs[x] with
                        | Msg r_p delta_p pid -> if (not (delta_p[k] = -1)) then res := True; temp := delta_p[k] 
                        end
                done;
                
                if (v_p[k] = -1) && !res
                then
                    v_p[k] <- !temp;
                    delta_p[k]<- !temp   
            done
        done;

        (* Phase 2 *)
        for x = 0 to n-1 
        do
                assert { 
                    match (Msg r_p delta_p pid), r_p, delta_p, pid with
                    | (Msg r_p v_p pid), r_p1, delta_p, pid1 -> if r_p1=r_p && pid1= pid then True else False
                    | _ -> False
                    end 
                };
        done

end